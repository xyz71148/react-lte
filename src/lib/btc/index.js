export const combo_coin_links = (
    "btc|usdt|ltc|eth|okb|etc|bch|eos|xrp|trx|bsv|dash|neo|qtum|xlm|ada|aac|abt|act|ae|algo|apm|ark|atom|bat|bcd|bec|bkx|bnt|btg|btm|btt|chat|cmt|cro|ctxc|cvc|cvt|dai|dcr|dgb|dgd|doge|ec|edo|egt|elf|fair|ftm|gas|gnt|gto|gusd|hbar|hc|hdao|hpb|hyc|icx|int|iost|iota|itc|kan|kcash|knc|lamb|lba|leo|let|link|lrc|lsk|mana|mco|mdt|mith|mkr|mof|nano|nas|nuls|omg|ont|orbs|ors|pax|pay|ppt|pst|qun|r|rfr|rnt|road|rvn|sc|snt|soc|storj|swftc|tct|theta|topc|trio|true|tusd|usdc|vib|vnt|vsys|waves|wtc|wxt|xem|xmr|xtz|xuc|yee|you|zec|zen|zil|zip|zrx|ardr|gnx|nxt|pma|sbtc|snc|spnd|vite|auto"
).split("|")

export const coin_pairs_base = (
    "btc_usdt|ltc_usdt|eth_usdt|okb_usdt|etc_usdt|bch_usdt|eos_usdt|xrp_usdt|trx_usdt|bsv_usdt|dash_usdt|neo_usdt|qtum_usdt|xlm_usdt|ada_usdt|aac_usdt|abt_usdt|act_usdt|ae_usdt|algo_usdt|apm_usdt|ark_usdt|atom_usdt|bat_usdt|bcd_usdt|bec_usdt|bkx_usdt|bnt_usdt|btg_usdt|btm_usdt|btt_usdt|chat_usdt|cmt_usdt|cro_usdt|ctxc_usdt|cvc_usdt|cvt_usdt|dai_usdt|dcr_usdt|dgb_usdt|dgd_usdt|doge_usdt|ec_usdt|edo_usdt|egt_usdt|elf_usdt|fair_usdt|ftm_usdt|gas_usdt|gnt_usdt|gto_usdt|gusd_usdt|hbar_usdt|hc_usdt|hdao_usdt|hpb_usdt|hyc_usdt|icx_usdt|int_usdt|iost_usdt|iota_usdt|itc_usdt|kan_usdt|kcash_usdt|knc_usdt|lamb_usdt|lba_usdt|leo_usdt|let_usdt|link_usdt|lrc_usdt|lsk_usdt|mana_usdt|mco_usdt|mdt_usdt|mith_usdt|mkr_usdt|mof_usdt|nano_usdt|nas_usdt|nuls_usdt|omg_usdt|ont_usdt|orbs_usdt|ors_usdt|pax_usdt|pay_usdt|ppt_usdt|pst_usdt|qun_usdt|r_usdt|rfr_usdt|rnt_usdt|road_usdt|rvn_usdt|sc_usdt|snt_usdt|soc_usdt|storj_usdt|swftc_usdt|tct_usdt|theta_usdt|topc_usdt|trio_usdt|true_usdt|tusd_usdt|usdc_usdt|vib_usdt|vnt_usdt|vsys_usdt|waves_usdt|wtc_usdt|wxt_usdt|xem_usdt|xmr_usdt|xtz_usdt|xuc_usdt|yee_usdt|you_usdt|zec_usdt|zen_usdt|zil_usdt|zip_usdt|zrx_usdt|ltc_okb|etc_okb|eos_okb|xrp_okb|trx_okb|dash_okb|neo_okb|ae_okb|egt_okb|iota_okb|sc_okb|wxt_okb|zec_okb|ltc_btc|eth_btc|okb_btc|etc_btc|bch_btc|eos_btc|xrp_btc|trx_btc|bsv_btc|dash_btc|neo_btc|qtum_btc|xlm_btc|ada_btc|aac_btc|abt_btc|act_btc|ae_btc|algo_btc|apm_btc|ardr_btc|ark_btc|atom_btc|bat_btc|bcd_btc|bec_btc|bkx_btc|bnt_btc|btg_btc|btm_btc|btt_btc|chat_btc|cmt_btc|cro_btc|ctxc_btc|cvc_btc|cvt_btc|dcr_btc|dgb_btc|dgd_btc|edo_btc|egt_btc|elf_btc|gas_btc|gnt_btc|gnx_btc|gto_btc|gusd_btc|hbar_btc|hc_btc|hpb_btc|hyc_btc|icx_btc|int_btc|iost_btc|iota_btc|itc_btc|kan_btc|kcash_btc|knc_btc|lba_btc|leo_btc|let_btc|link_btc|lrc_btc|lsk_btc|mana_btc|mco_btc|mdt_btc|mith_btc|mkr_btc|mof_btc|nano_btc|nas_btc|nuls_btc|nxt_btc|omg_btc|ont_btc|ors_btc|pax_btc|pay_btc|pma_btc|pst_btc|qun_btc|r_btc|rfr_btc|rvn_btc|sbtc_btc|sc_btc|snc_btc|snt_btc|soc_btc|spnd_btc|swftc_btc|tct_btc|theta_btc|trio_btc|true_btc|tusd_btc|usdc_btc|vib_btc|vite_btc|vsys_btc|waves_btc|wtc_btc|wxt_btc|xem_btc|xmr_btc|xtz_btc|you_btc|zec_btc|zen_btc|zil_btc|zip_btc|zrx_btc|ltc_eth|okb_eth|etc_eth|eos_eth|xrp_eth|trx_eth|dash_eth|neo_eth|qtum_eth|xlm_eth|ada_eth|aac_eth|abt_eth|ae_eth|algo_eth|atom_eth|auto_eth|btm_eth|btt_eth|cmt_eth|ctxc_eth|cvc_eth|dcr_eth|dgd_eth|egt_eth|elf_eth|fair_eth|gas_eth|gnx_eth|gto_eth|hc_eth|hpb_eth|hyc_eth|int_eth|iost_eth|iota_eth|kan_eth|kcash_eth|leo_eth|link_eth|lrc_eth|mana_eth|mco_eth|mdt_eth|mith_eth|mkr_eth|mof_eth|nano_eth|nas_eth|nuls_eth|omg_eth|ont_eth|ors_eth|sc_eth|storj_eth|swftc_eth|topc_eth|trio_eth|true_eth|waves_eth|wtc_eth|xem_eth|xmr_eth|you_eth|zec_eth|zen_eth|zil_eth|zrx_eth|btc_dai|eth_dai"
).split("|")
export const make_coin_pairs = (coin_pairs_base) => {
    const res = {}
    coin_pairs_base.map((row) => {
        row = row.replace("_", "-").toUpperCase()
        const t = row.split("-")
        res[t[0] + "-" + t[1]] = row
        res[t[1] + "-" + t[0]] = row
        return row;
    })
    return res
};
const coin_pairs_object = make_coin_pairs(coin_pairs_base)
export function handle_combo_result(combo,prices) {
    //console.log(this.fetch_result, moment.unix(+(new Date) / 1000).format("YYYY-MM-DD HH:mm:ss"))
    const r = {}
    r["combo"] = combo;
    r["pairs"] = [
        `${combo[0]}-${combo[1]}`,
        `${combo[1]}-${combo[2]}`,
        `${combo[2]}-${combo[0]}`
    ];

    r["pairs_fetch"] = [
        coin_pairs_object[r["pairs"][0]],
        coin_pairs_object[r["pairs"][1]],
        coin_pairs_object[r["pairs"][2]],
    ];

    r["fee"] = [
        parseFloat(prices[r["pairs_fetch"][0]]),
        parseFloat(prices[r["pairs_fetch"][1]]),
        parseFloat(prices[r["pairs_fetch"][2]]),
    ]

    r['price_base'] = 100;
    r['exchange_fee'] = 1 - 0.0015;
    r['price'] = [];
    r['price'][0] = r["pairs_fetch"][0] === r["pairs"][0] ?
        r['exchange_fee'] * r['price_base'] * r["fee"][0] :
        r['exchange_fee'] * r['price_base'] / r["fee"][0];

    r['price'][1] = r["pairs_fetch"][1] === r["pairs"][1] ?
        r['exchange_fee'] * r['price'][0] * r["fee"][1] :
        r['exchange_fee'] * r['price'][0] / r["fee"][1];

    r['price'][2] = r["pairs_fetch"][2] === r["pairs"][2] ?
        r['exchange_fee'] * r['price'][1] * r["fee"][2] :
        r['exchange_fee'] * r['price'][1] / r["fee"][2];
    r["diff"] = r['price'][2] - r['price_base']
    return r;
}


export function permutationAndCombination(source = [], selectedLimit, isPermutation = true) {
    if (!Array.isArray(source)) return source

    // remove duplicated item
    source = [...new Set(source)]
    selectedLimit = selectedLimit || source.length

    const result = []
    const sourceLen = source.length

    selectedLimit = selectedLimit > sourceLen ? sourceLen : selectedLimit

    const innerLoop = (prefix = [], done = [], index = 0) => {
        const prefixLen = prefix.length

        for (let i = isPermutation ? 0 : index; i < sourceLen; i++) {

            if (prefixLen > selectedLimit - 1) break

            // Optimization: Continue to next cycle if current item has be already used for 'prefix'.
            if (done.includes(i)) continue

            const item = source[i]
            const newItem = [...prefix, item]

            if (prefixLen === selectedLimit - 1) {
                result.push(newItem)
            }

            if (prefixLen < selectedLimit - 1) {
                innerLoop(newItem, [...done, i], index++)
            }

        }
    }

    if (source.length) {

        // there is only one case if we want to select all items from source by combination.
        if (!isPermutation && selectedLimit === sourceLen) {
            return source
        }

        innerLoop()
    }

    return result
}

